# CMAKE STUDY

### Генераторы:
Генераторами называются компоненты инструмента CMake, отвечающие за создание проектов для конечных систем построения.
Для каждой поддерживаемой системы (make, Microsoft Visual Studio определенной версии и т.д.) существует свой генератор. 
Выбор конкретного генератора задаётся в командной строке CMake при помощи ключа "-G".
```bash
$ cmake -G "Visual Studio 14 2015" ..\project_src
```

Полный список имён поддерживаемых генератором для данной версии можно узнать при помощи команды:
```bash
$ cmake --help
```

Ключ "-A" позволяет указать целевую платформу (ARM, x64, и т.д.)
***

### Входные файлы:
Входными файлами для программы CMake являются файлы CMakeLists.txt, лежащие в корне каталога проекта (с файлами исходных кодов).
Путь к каталогу проекта предаётся инструменту CMake в качестве последнего аргумента командной строки.
Крупные проекты могут также содержать подкаталоги с проектами нижнего уровня, каждый из которых будет иметь в корне свой файл CMakeLists.txt
Кроме файлов CMakeLists.txt также могут использоваться файлы с расширением ".cmake". Эти файлы могут подключаться из программы на языке CMake
при помощи директивы _include(...)_, вызываться при исполнении команды _find_package(...)_ (модули поиска или конфигурационные файлы) или передаваться
инструменту CMake для исполнения при помощи ключа "-P"
***

### Комментарии:
	# - Однострочный комментарий.
	#[[ ]] - Блочный комментарий.
***

### Команды общего назначения:
Команда _cmake_minimum_required(...)_ определяет минимальную версию инструмента CMake, при помощи которого можно обрабатывать текущий входной файл проекта. Аргумент _{версия}_ может содержать до 4 чисел, разделенных точками. Команду _cmake_minimum_required(...)_ рекомендуется указывать самой первой в файле CMakeLists.txt верхнего уровня.
```cmake
cmake_minimum_required(VERSION {версия} [FATAL_ERROR])
```

Команда _project(...)_ устанавливает имя для иерархии проектов. Например, для генераторов Microsoft Visual Studio это имя определяет имя создаваемого решения.
```cmake
project({имя_проекта} [VERSION {версия}] [LANGUAGES {язык1} ... {языкN}])
```
* После аргумента VERSION можно указать версию проекта - строку, содержащую до 4 чисел, разделенных точками. Установка версии проекта доступна в CMake начиная с версии 3.0.
* После необязательного аргумента LANGUAGES указываются языки программирования, для которых обеспечивается поддержка в проекте.

Команда _include(...)_ загружает из внешнего файла и исполняет заданный модуль CMake. Модуль может задаваться при помощи пути к файлу, либо только именем модуля (без пути и расширения). В последнем случае файл с именем _{модуль}.cmake_ ищется в каталогах, список которых задан переменной _CMAKE_MODULE_PATH_ (по умолчанию пустая), и затем в каталоге стандартных модулей, поставляемых вместе с CMake.
```cmake
include({файл} | {модуль} [OPTIONAL] [RESULT_VARIABLE {имя_переменной}])
```

Команда _message(...)_ предназначена для вывода сообщения различными утилитами, интерпретирующими входной файл.
```cmake
message([{режим}] {строка1} ... {строка2})
```
```
{режим} = STATUS | WARNING | AUTHOR_WARNING | SEND_ERROR | FATAL_ERROR | DEPRECATION
```
***

### Команды генерации целей:
Команда _add_executable(...)_ добавляет к проекту цель с заданным логическим именем, построение которой из указанных исходных модулей должно привести к созданию исполняемого файла.
```cmake
add_executable({логическое_имя_цели} [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] {исходный_модуль1} ... {исходный_модульN})
```
Изменить имя можно при помощи установки свойства _OUTPUT_NAME_ цели.
```cmake
set_property(TARGET {имя_цели} PROPERTY OUTPUT_NAME {имя_выходного_файла})
```
_CMAKE_RUNTIME_OUTPUT_DIRECTORY_ содержит имя подкатолога построения.
Использование аргумента _WIN32_ приведёт к отключению консоли при построении на платформе Windows.
Для остальных платформ этот аргумент игнорируется.
Передача аргумента _EXCLUDE_FROM_ALL_ приведет к тому, что генерируемая цель будет исключена
из цели "all".

Первая форма команды _add_library(...)_ аналогична команде _add_executable(...)_, но создаёт цель для построения библиотеки.
```cmake
add_library({логическое_имя_цели} [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] {исходный_модуль1} ... {исходный_модульN})
add_library({логическое_имя_цели} {тип_библиотеки = SHARED | STATIC | MODULE | UNKNOWN} IMPORTED)
```

Тип библиотеки можно задать при помощи необязательного аргумента:
* STATIC: статическая;
* SHARED: динамическая (разделяемая);
* MODULE: разделяемая, предназначенная исключительно для загрузки при помощи функций API (POSIX dlopen() и т.п.). Такой тип библиотеки используется для реализации загружаемых модулей (plugins).

Изменить расположение библиотеки можно при помощи соответствующих свойств цели, которые инициализируются значениями специальных
переменных:
Имя свойства|Тип библиотеки
-------------------------------|-----------------------------
CMAKE_ARCHIVE_OUTPUT_DIRECTORY | статические(+импорта)
CMAKE_RUNTIME_OUTPUT_DIRECTORY | DLL
CMAKE_LIBRARY_OUTPUT_DIRECTORY | модули, разделяемые

_Размещение библиотек в разных ОС стр. 85_

Вторая форма команды _add_library(...)_ предназначена для добавления к проекту внешней заранее собранной библиотеки (как правило, сторонней). Как и для предыдущей формы команды, создаётся цель с заданным логическим именем, которая по умолчанию имеет область видимости текущего каталога построения и ниже и которую можно использовать, как и остальные цели библиотек, для связывания с другими целями проекта при помощи команды
_target_link_libraries(...)_. Однако в этом случае не создаётся никаких правил построения библиотеки.

Чтобы указать местоположение файла библиотеки для создаваемой цели, необходимо записать его в свойство цели _IMPORTED_LOCATION_, а также в свойства _IMPORTED_LOCATION_DEBUG_ и т.д. для каждой используемой конфигурации. Для получения пути к исполняемому файлу библиотеки можно использовать команду _find_library(...)_.

Команда _add_subdirectory(...)_ добавляет к построению подпроект, расположенный заданном подкаталоге. В нём должен находиться файл CMakeLists.txt с описанием подпроекта.
```cmake
add_subdirectory({подкаталог_проекта} [{подкаталог_построения}] [EXCLUDE_FROM_ALL])
```
Имеет смысл указывать относительный путь к каталогу.
* При помощи необязательного аргумента {подкаталог_построения} можно указать подкаталог для выходных и промежуточных файлов проекта.

### Команды настроек целей
Команда _include_directories(...)_ добавляет указанные каталоги к списку каталогов в которых компилятор должен искать заголовочные файлы, подключаемые директивами #include. Эти каталоги добавляются к соответствующему свойству всех целей, определенных в текущем файле CMakeLists.txt. Относительные пути интерпретируются по отношению к текущему каталогу исходных файлов проекта.
```cmake
include_directories([AFTER | BEFORE] [SYSTEM] {каталог1} ... {каталогN})
```
* При помощи необязательного аргумента BEFORE или AFTER можно сообщить команде, что заданные в ней каталоги должны добавляться  в начало или конец списка каталогов для поиска
* При помощи аргумента SYSTEM можно сообщить, что указанные каталоги являются системными (относящимися к компилятору).

Результат исполнения команды _target_include_directories(...)_ аналогичен вызову команды _include_directories(...)_, основные же отличия состоят в следующем:
* В аргументе команды указывается имя цели к которой она относится. Команда влияет на соответствующие свойства этой цели, в то время как команда _include_directories_(...)_ влияет на свойство каталога проекта (т.е. действует на все цели, определяемые в текущем подпроекте).
* Есть возможность указать, будут ли использованы указанные в аргументах команды каталоги для компиляции самой цели или для зависимых от неё целей.
```cmake
target_include_directories({имя_цели} [SYSTEM] [BEFORE] INTERFACE | PUBLIC | PRIVATE [{каталог1,1} ... {каталог1,M}]
[
	INTERFACE | PUBLIC | PRIVATE [{каталог2,1} ... {каталог2, n})
...
])
```
Перед путями к каталогам укзывается один из следующих аргументов:
* PRIVATE: каталоги будут использованы для поиска заголовочных файлов при компиляции файлов текущей цели (аналогично команде _include_directories(...)_).
* INTERFACE: каталоги будут использованы при компиляции файлов зависимых целей от текущей.
* PUBLIC: каталоги будут использованы при компиляции файлов как текущей цели, так и зависимых от неё целей (как будто они описаны одновременно как PRIVATE и INTERFACE)
Таким образом, команда позволяет упростить подключение библиотек к исполяемым файлам.
